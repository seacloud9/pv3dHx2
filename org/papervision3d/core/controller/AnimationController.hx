package org.papervision3d.core.controller {	import flash.events.EventDispatcher;	import flash.utils.getTimer;		import org.papervision3d.core.animation.IAnimatable;	import org.papervision3d.core.animation.channel.Channel3D;	import org.papervision3d.core.animation.clip.AnimationClip3D;	import org.papervision3d.events.AnimationEvent;		/**	 * The AnimationController class controls an animation.	 * 	 * @author Tim Knip / floorplanner.com	 */	class AnimationController extends EventDispatcher implements IObjectController, IAnimatable	{		/**		 * Start time of animation in seconds. 		 */		public var startTime:Float;				/**		 * End time of animation in seconds. 		 */		public var endTime:Float;				/**		 * 		 */		private var _channels:Array<Dynamic>;				/**		 * 		 */		private var _isPlaying:Bool;				/**		 * 		 */		private var _isPaused:Bool;				/**		 * 		 */		private var _currentTime:Float;				/**		 * 		 */		private var _currentTimeStamp:Int;				/**		 * 		 */		private var _pauseTime:Float;				/**		 * 		 */		private var _loop:Bool;				/** */		private var _clip:AnimationClip3D;				/** */		private var _clips:Array<Dynamic>;				/** */		private var _clipByName:Dynamic;				/** */		private var _dispatchEvents:Bool;				/**		 * Constructor.		 */		public function new(dispatchEvents:Bool=true)		{			super();						_dispatchEvents=dispatchEvents;						init();					}		/**		 * 		 */		public function addChannel(channel:Channel3D):Channel3D 		{			if(_channels.indexOf(channel)==-1)			{				_channels.push(channel);				updateStartAndEndTime();				return channel;			}			return null;		}		/**		 * 		 */		public function addClip(clip:AnimationClip3D):AnimationClip3D		{			if(_clips.indexOf(clip)==-1)			{				_clips.push(clip);				_clipByName[clip.name]=clip;				return clip;			}			return null;			}		/**		 * 		 */		public function clone():AnimationController		{			var controller:AnimationController=new AnimationController();			var channel:Channel3D;			var cloned:Channel3D;			var i:Int;						for(i=0;i<_channels.length;i++)			{				channel=_channels[i];				cloned=channel.clone();				controller.addChannel(cloned);			}			return controller;
	}		/**		 * Initialize.		 */		private function init():Void		{			_channels=new Array();			_clips=new Array();			_clipByName=new Dynamic();			_isPlaying=false;			_isPaused=false;			_currentTime=0;			_loop=false;			updateStartAndEndTime();		}				/**		 * Pause the animation.		 */		public function pause():Void		{			_pauseTime=_currentTime;			_isPaused=true;			_isPlaying=false;						if(_dispatchEvents)			{				var clipName:String=_clip ? _clip.name:"all";				dispatchEvent(new AnimationEvent(AnimationEvent.PAUSE, _pauseTime, clipName));			}		}
	/**		 * Plays the animation.		 * 		 * @param 	clip	Clip to play. Default is "all"		 * @param 	loop	Whether the animation should loop. Default is true.		 */ 		public function play(clip:String="all", loop:Bool=true):Void 		{			if(clip && clip.length && _clipByName[clip] is AnimationClip3D)			{					_clip=_clipByName[clip];			}			else			{				_clip=null;			}						if(_channels.length)			{				_loop=loop;				_currentTimeStamp=getTimer();				if(_clip)				{					_currentTimeStamp -=(_clip.startTime * 1000);					}				_isPlaying=true;				_isPaused=false;			}						if(_dispatchEvents)			{				var clipName:String=_clip ? _clip.name:"all";				var time:Float=_clip ? _clip.startTime:0;								dispatchEvent(new AnimationEvent(AnimationEvent.START, time, clipName));			}		}		/**		 * 		 */		public function removeAllChannels():Void		{			while(_channels.length)			{				_channels.pop();			}			updateStartAndEndTime();		}				/**		 * 		 */		public function removeChannel(channel:Channel3D):Channel3D		{			var pos:Int=_channels.indexOf(channel);			if(pos>=0)			{				_channels.splice(pos, 1);				updateStartAndEndTime();				return channel;			}			return null;		}				/**		 * Removes a clip.		 * 		 * @param clip		 * 		 * @return	The removed clip or null on failure.		 */		public function removeClip(clip:AnimationClip3D):AnimationClip3D		{			var pos:Int=_clips.indexOf(clip);			if(pos>=0)			{				_clips.splice(pos, 1);				_clipByName[clip.name]=null;				return clip;			}			return null;		}				/**		 * Resumes the animation.		 * 		 *  @param loop	Whether the animation should loop. Defaults to true;		 */		public function resume(loop:Bool=true):Void		{			if(_channels.length)			{				_loop=loop;				_currentTimeStamp=getTimer();				if(_isPaused)				{					_currentTimeStamp=getTimer()- _pauseTime * 1000;					}				_isPlaying=true;				_isPaused=false;								if(_dispatchEvents)				{					var clipName:String=_clip ? _clip.name:"all";					dispatchEvent(new AnimationEvent(AnimationEvent.RESUME, _pauseTime, clipName));				}			}		}		/**		 * Stops the animation.		 */		public function stop():Void		{				_isPlaying=false;						if(_dispatchEvents)			{				var endTime:Float=_clip ? _clip.endTime:this.endTime;				var clipName:String=_clip ? _clip.name:"all";							dispatchEvent(new AnimationEvent(AnimationEvent.STOP, endTime, clipName));			}		}				/**		 * Update.		 */		public function update():Void 		{			if(!_isPlaying || _isPaused || !_channels.length)			{				return;			}						var t:Int=getTimer();			var elapsed:Int=t - _currentTimeStamp;			var channel:Channel3D;			var et:Float=_clip ? _clip.endTime:endTime;			var clipName:String=_clip ? _clip.name:"all";						_currentTime=(elapsed * 0.001);			if(_currentTime>et)			{				if(_dispatchEvents)				{					dispatchEvent(new AnimationEvent(AnimationEvent.COMPLETE, et, clipName));				}									if(!_loop)				{					stop();					return;				}				_currentTimeStamp=t;				if(_clip)				{					_currentTimeStamp -=(_clip.startTime * 1000);				}				_currentTime=_clip ? _clip.startTime:startTime;			}						for(channel in _channels)			{				channel.update(_currentTime);			}						if(_isPlaying && _dispatchEvents)			{				dispatchEvent(new AnimationEvent(AnimationEvent.NEXT_FRAME, _currentTime, clipName));			}		}		/**		 * Updates the startTime and endTime of this animation controller.		 */		private function updateStartAndEndTime():Void		{			var channel:Channel3D;						if(_channels.length==0)			{				startTime=endTime=0;				return;			}						startTime=Number.MAX_VALUE;			endTime=-startTime;					for(channel in _channels)			{				startTime=Math.min(startTime, channel.startTime);				endTime=Math.max(endTime, channel.endTime);			}		}				/**		 * 		 */		override public function toString():String		{			return "[AnimationController] #channels:" + _channels.length + " startTime:" + startTime + " endTime:" + endTime;		}				private function set_channels(value:Array):Void		{			_channels=value;			}				public var channels(get_channels, set_channels):Array;
 	private function get_channels():Array		{			return _channels;		}				public var currentTime(get_currentTime, set_currentTime):Float;
 	private function get_currentTime():Float		{			return _currentTime;			}				/**		 * Gets all defined clip names. This property is read-only.		 * 		 * @return Array containing clip names.		 */		public var clipNames(get_clipNames, set_clipNames):Array;
 	private function get_clipNames():Array		{			var names:Array<Dynamic>=new Array();				var clip:AnimationClip3D;						for(clip in _clips)			{				names.push(clip.name);			}			return names;		}				/**		 * Gets all defined clips. This property is read-only.		 * 		 * @return Array containing clips.		 * 		 * @see org.papervision3d.core.animation.clip.AnimationClip3D		 */		public var clips(get_clips, set_clips):Array;
 	private function get_clips():Array		{			return _clips;		}				/**		 * 		 */		public var dispatchEvents(get_dispatchEvents, set_dispatchEvents):Bool;
 	private function get_dispatchEvents():Bool		{			return _dispatchEvents;		} 				/**		 * 		 */		private function set_dispatchEvents(value:Bool):Void		{			_dispatchEvents=value;			}				/**		 * Float of channels.		 */		public var numChannels(get_numChannels, null):Int;
 	private function get_numChannels():Int		{			return _channels.length;		}				/**		 * Whether the animation is playing. This property is read-only.		 */		public var playing(get_playing, null):Bool;
 	private function get_playing():Bool		{			return _isPlaying;		}	}