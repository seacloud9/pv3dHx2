package org.papervision3d.objects.special {	import org.papervision3d.core.proto.GeometryObject3D;			import flash.display.BitmapData;	import flash.geom.Matrix;		import org.papervision3d.core.geom.renderables.Vertex3D;	import org.papervision3d.objects.special.commands.BeginFill;	import org.papervision3d.objects.special.commands.CurveTo;	import org.papervision3d.objects.special.commands.EndFill;	import org.papervision3d.objects.special.commands.LineStyle;	import org.papervision3d.objects.special.commands.LineTo;	import org.papervision3d.objects.special.commands.MoveTo;	import org.papervision3d.objects.DisplayObject3D;			/**	 * @author Mark Barcinski	 */	class Graphics3D {		private var vectorshape:VectorShape3D;		public function new(vectorshape:VectorShape3D){			this.vectorshape=vectorshape;		}				public function beginFill(color:Int, alpha:Float=1):Void		{			vectorshape.graphicsCommands.push(new BeginFill(color , alpha));			}				public function endFill():Void		{			vectorshape.graphicsCommands.push(new EndFill());			}		public function curveTo(controlX:Float , controlY:Float , anchorX:Float , anchorY:Float):Void		{			var v:Vertex3D=new Vertex3D(controlX , controlY , 0);			vectorshape.geometry.vertices.push(v);						var vc:Vertex3D=new Vertex3D(anchorX, anchorY , 0);			vectorshape.geometry.vertices.push(vc);						vectorshape.graphicsCommands.push(new CurveTo(v , vc));		}				public function lineTo(x:Float , y:Float):Void		{			var v:Vertex3D=new Vertex3D(x , y , 0);			vectorshape.geometry.vertices.push(v);			vectorshape.graphicsCommands.push(new LineTo(v));		}				public function moveTo(x:Float , y:Float):Void		{			var v:Vertex3D=new Vertex3D(x , y , 0);			vectorshape.geometry.vertices.push(v);			vectorshape.graphicsCommands.push(new MoveTo(v));		}				public function lineStyle(thickness:Float=-1, color:Int=0, alpha:Float=1.0, pixelHinting:Bool=false, scaleMode:String="normal", caps:String=null, joints:String=null, miterLimit:Float=3):Void 		{			//NOTE stroke doesn't scale with perspective			vectorshape.graphicsCommands.push(new LineStyle(thickness, color , alpha, pixelHinting, scaleMode, caps, joints, miterLimit));		}		public function drawRect(x:Float, y:Float, width:Float, height:Float):Void		{			moveTo(x, y);			lineTo(x + width, y);			lineTo(x + width, y + height);			lineTo(x, y + height);			lineTo(x, y);		}				public function drawRoundRect(x:Float, y:Float, width:Float, height:Float, ellipseWidth:Float, ellipseHeight:Float):Void		{			moveTo(x, y + ellipseHeight);			curveTo(x, y , x + ellipseWidth, y);						lineTo(x + width - ellipseWidth, y);			curveTo(x + width , y , x + width , y + ellipseHeight);						lineTo(x + width, y + height - ellipseHeight);			curveTo(x + width, y + height , x + width - ellipseHeight, y + height);						lineTo(x + ellipseWidth, y + height);			curveTo(x , y + height , x , y + height - ellipseHeight);						lineTo(x, y + ellipseHeight);		}				public function clear():Void		{			vectorshape.geometry.vertices=[];			vectorshape.geometry.faces=[];			vectorshape.graphicsCommands=[];		}		 		public function drawCircle(x:Float, y:Float, radius:Float , numPoints:Int=8):Void		{			drawEllipse(x  , y , radius  , radius  , numPoints);		}				//Based on Keith Peters MultiCurves		public function drawEllipse(x:Float , y:Float , width:Float , height:Float , numPoints:Int=8):Void		{			var points:Array<Dynamic>=new Array();			var step:Float=2 * Math.PI / numPoints;			for(i in 0...numPoints)			{				points[i]=new Dynamic();				points[i].x=x + Math.sin(i * step)* width;				points[i].y=y + Math.cos(i * step)* height;			}						// find the first midpoint and move to it			var xc1:Float=(points[0].x + points[numPoints - 1].x)/ 2;			var yc1:Float=(points[0].y + points[numPoints - 1].y)/ 2;			moveTo(xc1, yc1);			// curve through the rest, stopping at midpoints			for(i=0;i<numPoints - 1;i ++)			{				var xc:Float=(points[i].x + points[i + 1].x)/ 2;				var yc:Float=(points[i].y + points[i + 1].y)/ 2;				curveTo(points[i].x, points[i].y, xc, yc);			}						// curve through the last point, back to the first midpoint			curveTo(points[i].x, points[i].y, xc1, yc1);		}		/*		public function drawRoundRectComplex(x:Float, y:Float, width:Float, height:Float, topLeftRadius:Float, topRightRadius:Float, bottomLeftRadius:Float, bottomRightRadius:Float):Void		{					}		public function lineGradientStyle(type:String, colors:Array, alphas:Array, ratios:Array, matrix:Matrix=null, spreadMethod:String="pad", InterpolationMethod:String="rgb", focalPointRatio:Float=0):Void		{					}		public function beginBitmapFill(bitmap:BitmapData, matrix:Matrix=null, repeat:Bool=true, smooth:Bool=false):Void		{					}		public function beginGradientFill(type:String, colors:Array, alphas:Array, ratios:Array, matrix:Matrix=null, spreadMethod:String="pad", InterpolationMethod:String="rgb", focalPointRatio:Float=0):Void		{					}*/	}